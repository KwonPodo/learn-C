# 최단 경로 문제 (Shortest Path Problem)
    : 가중 그래프에서 주어진 두 정점 A와 B를 연결하는 경로들 중, 그 가중치의 합이 가장 작은 경로를 찾아내는 문제.
   
<br>

> 최소비용신장트리(Minimum Cost Spanning Tree)와는 다르다.
>> 최소비용(Minimum Cost): 최소한의 비용(가중치)
>> 신장트리(Spanning Tree):  모든 정점을 걸치고 있는 트리
>>> **즉, 최소비용신장트리 문제의 목적은 최소한의 비용으로 주어진 모든 정점을 연결하는 것이고, 
최단경로트리를 구하는 것은 한 정점에서 나머지 다른 각 정점에 대해 최단경로, 최소비용의 경로를 찾는 것이다.**
x
## 알고리즘

### 우선순위 탐색(Priority Search First)
    최단경로문제 
    == 
    최단경로트리(Shortest Path Tree)를 찾는 문제로 바꾸어 생각할 수 있다.
#### 최단경로트리(Shortest Path Tree)
: _하나의 정점 V에서 나머지 각 정점에 이르는 최단경로를 나타낸 트리._
<br>

    최소비용신장트리를 구할 때와 같이 우선순위큐를 사용하되, 우선순위의 기준은 **가중치의 누적값**으로 하면 최단경로트리를 구할 수 있다.
    이때 가중치의 누적값의 의미는 바로 경로의 비용이다.

    최소비용신장트리에서 우선순위큐에 저장하는 자료는 해당 정점에 이르는 간선들 중 가장 비용이 적은 간선이었다면,
    최단경로트리의 우선순위큐에 저장하는 자료는 해당 정점에 도달하기 위한 경로의 비용 중, 가장 비용이 적은 경로이다.

    **이 차이는 바로 단일 비용이 낮은 간선이냐, 아니면 전체 비용이 낮은 경로를 저장하냐의 차이이다.**

    즉, 우선순위큐에는 해당 정점에 도달하기 위한 경로들 중에서 가장 비용이 적게 드는 경로,
    즉 누적가중치값이 가장 작은 경로를 저장한다.

1. 어떠한 하나의 정점 V를 시작정점으로 하여 결과트리에 추가한다.
   * 우선순위큐에 있는 정점(간선)들 중, 가장 우선순위가 높은 정점(간선)을 꺼내 결과트리에 추가한다.
2. V와 간선으로 이어진 인접 정점들을 가중치의 최소 누적값과 함께 우선순위큐에 넣는다.
   * 이미 우선순위큐에 있는 정점의 경우 : (정점 V의 누적가중치 + V-W간선의 가중치)와 우선순위큐에 저장된 W에 이르는 현재까지의 최소누적가중치를 비교하여 더 값이 작은 것으로 W에 이르는 누적가중치를 갱신한다.
    => 현재의 정점 V를 통해 W로 연결된 경로와 지금까지 찾은 최단경로를 비교하여 둘 중 최단경로를 우선순위큐에 저장한다.
   * 우선순위큐에 아직 넣지 않은 정점의 경우 : (정점 V의 누적가중치 + V-W간선의 가중치)를 정점 W와 함께 우선순위큐에 저장한다.